# 자바 정리

## 1강 자바 기초
### (1)
```
package PackageName //파일이 위치할 패키지 선언

public class ClassName { //클래스 선언
  public static void main(String[] args) { //main() 메소드 선언
    //실행 코드
  }
}
```

### (2) 주석
```
// 한 줄 주석
'''
여러
줄
주석
'''
```

## 2강 변수와 타입
### (1) 변수 선언
- 타입 + 이름
- 첫 글자는 문자, 중간에 문자, 숫자, $, _ 포함 가능
- 첫 문자를 소문자로 시작하되 캐멜(camel)스타일로 작성하는 것이 관례
- 예약어 사용 불가

### (2) 정수 타입

|타입|메모리크기|저장되는 값의 허용 범위|
|---|---|---|
|byte|1byte|-128 ~ 127|
|short|2byte|-32,768 ~ 32,767|
|char|2byte|0 ~ 65535(유니코드)|
|int|4btye|-2,147,483,648 ~ 2,147,483,647|
|long|8byte|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|

### (3) 문자 타입
```
char var1 = 'A' //문자 저장
char var2 = '65' //유니코드 직접 저장
char c = "A" //큰 따옴표는 컴파일 에러
char c = ' '; //공백 하나를 포함해서 초기화
```

### (4) 실수 타입

|타입|메모리크기|유효 소수 이하 자리|
|---|---|---|
|float|4byte|7자리|
|double|8byte|15자리|

### (5) 논리 타입
```
boolean stop = true;
boolean stop = false;
```
### (6) 문자열 타입
'''
String var1 = "A";
String var2 = "홍길동";
'''

|이스케이프 문자||
|\t|출력시 탭만큼 띄움|
|\n|출력 시 줄바꿈|

### (7) 자동 타입 변환
- 값의 허용 범위가 작은 타입이 허용 범위가 큰 타입으로 대입될 떄 발생
- 허용 범위 순 나열
    - byte < short, char < int < long < float < double

### (8) 강제 타입 변환
- 캐스팅 연산자 괄호() 사용

### (9) 문자열 변환
|변환 타입||
|-|-|
| byte | Byte.parseByte(); |
| short | Short.parseShort(); |
| int | Integer.parseInt(); |
| long | Long.parseLong(); |
| float | Float.parseFloat(); |
| double | Double.parseDouble(); |
| boolean | Boolean.parseBoolean();|

### (10) 출력
```
System.out.println("출력 후 줄바꿈");
System.out.print("출력 후 줄 변환 없음");
System.out.printf("형식문자열", 값1, 값2...);
```

### (11) 스캐너
```
package ch02.sec13;

import java.util.Scanner;

public class ScannerExample {
  public class void main(String[] args) {
    Scanner s = new Scaaner(System.in);

    System.out.print("x 값 입력 : ");
    String strX = s.nextLine();
  }
}
```

## 3강

### (1) 연산자
|연산식||설명|
|---|---|---|
|+|피연산자||
|-|피연산자||
|++|피연산자|피연산자의 값을 1 증가|
|--|피연산자|피연산자의 값을 1 감소|
|피연산자|++|다른 연산 수행 후 피연산자의 값 1 증가|
|피연산자|--|다른 연산 수행 후 피연산자의 값 1 감소|

### (2) 산술 연산자
|연산식|||설명|
|---|---|---|---|
|피연산자|`+`|피연산자|덧셈|
|피연산자|`-`|피연산자|뺄셈|
|피연산자|`*`|피연산자|곱셈|
|피연산자|`/`|피연산자|나눗셈|
|피연산자|`%`|피연산자|나눗셈의 나머지|

### (3) 비교 연산자

|구분|연산식|||설명|
|-|-|-|-|-|
|동등비교|피연산자1|`==`|피연산자2|두 피연산자의 값이 같은지 검사|
||피연산자1|`!=`|피연산자2|두 피연산자의 값이 다른지 검사|
|크기비교|피연산자1|`>`|피연산자2|피연산자1이 큰지 검사|
||피연산자1|`>=`|피연산자2|피연산자1이 크거나 같은지 검사|
||피연산자1|`<`|피연산자2|피연산자1이 작은지 검사|
||피연산자1|`<=`|피연산자2|피연산자1이 작거나 같은지 검사|

### (4) 논리 연산자
### 3.7 논리 연산자
| 구분 | 피연산자1 | 연산자 | 피연산자2 | 결과 | 설명 |
| :---: | :---: | :---: | :---: | :---: | :--- |
| **AND**<br>(논리곱) | true<br>true<br>false<br>false | `&&`<br>또는<br>`&` | true<br>false<br>true<br>false | **true**<br>false<br>false<br>false | 피연산자 모두가 true일 경우에만<br>연산 결과가 true |
| **OR**<br>(논리합) | true<br>true<br>false<br>false | `\|\|`<br>또는<br>`\|` | true<br>false<br>true<br>false | **true**<br>**true**<br>**true**<br>false | 피연산자 중 하나만 true이면<br>연산 결과는 true |
| **XOR**<br>(배타적 논리합) | true<br>true<br>false<br>false | `^` | true<br>false<br>true<br>false | false<br>**true**<br>**true**<br>false | 피연산자가 하나는 true이고<br>다른 하나가 false일 경우에만<br>연산 결과가 true |
| **NOT**<br>(논리 부정) | | `!` | true<br>false | false<br>**true** | 피연산자의 논리값을 바꿈 |

### (5) 비트 논리 연산자
| 구분 | 비트1 | 연산자 | 비트2 | 결과 | 설명 |
| :---: | :---: | :---: | :---: | :---: | :--- |
| **AND**<br>(논리곱) | 1<br>1<br>0<br>0 | `&` | 1<br>0<br>1<br>0 | **1**<br>0<br>0<br>0 | 두 비트 모두 1일 경우에만<br>연산 결과가 1 |
| **OR**<br>(논리합) | 1<br>1<br>0<br>0 | `\|` | 1<br>0<br>1<br>0 | **1**<br>**1**<br>**1**<br>0 | 두 비트 중 하나만 1이면<br>연산 결과는 1 |
| **XOR**<br>(배타적 논리합) | 1<br>1<br>0<br>0 | `^` | 1<br>0<br>1<br>0 | 0<br>**1**<br>**1**<br>0 | 두 비트 중 하나는 1이고<br>다른 하나가 0일 경우<br>연산 결과는 1 |
| **NOT**<br>(논리 부정) | | `~` | 1<br>0 | 0<br>**1** | 보수 (비트 반전) |

### (6) 대입 연산자
| 구분 | 연산식 (변수 / 연산자 / 피연산자) | 설명 |
| :---: | :--- | :--- |
| **단순 대입 연산자** | `변수 = 피연산자` | 우측의 피연산자의 값을 변수에 저장 |
| **복합 대입 연산자** | `변수 += 피연산자` | 우측의 피연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장<br>(변수 = 변수 + 피연산자) |
| | `변수 -= 피연산자` | 우측의 피연산자의 값을 변수의 값에서 뺀 후에 다시 변수에 저장<br>(변수 = 변수 - 피연산자) |
| | `변수 *= 피연산자` | 우측의 피연산자의 값을 변수의 값과 곱한 후에 다시 변수에 저장<br>(변수 = 변수 * 피연산자) |
| | `변수 /= 피연산자` | 우측의 피연산자의 값으로 변수의 값을 나눈 후에 다시 변수에 저장<br>(변수 = 변수 / 피연산자) |
| | `변수 %= 피연산자` | 우측의 피연산자의 값으로 변수의 값을 나눈 후에 나머지를 변수에 저장<br>(변수 = 변수 % 피연산자) |
| | `변수 &= 피연산자` | 우측의 피연산자의 값과 변수의 값을 & 연산 후 결과를 변수에 저장<br>(변수 = 변수 & 피연산자) |
| | `변수 \|= 피연산자` | 우측의 피연산자의 값과 변수의 값을 \| 연산 후 결과를 변수에 저장<br>(변수 = 변수 \| 피연산자) |
| | `변수 ^= 피연산자` | 우측의 피연산자의 값과 변수의 값을 ^ 연산 후 결과를 변수에 저장<br>(변수 = 변수 ^ 피연산자) |
| | `변수 <<= 피연산자` | 우측의 피연산자의 값과 변수의 값을 << 연산 후 결과를 변수에 저장<br>(변수 = 변수 << 피연산자) |
| | `변수 >>= 피연산자` | 우측의 피연산자의 값과 변수의 값을 >> 연산 후 결과를 변수에 저장<br>(변수 = 변수 >> 피연산자) |
| | `변수 >>>= 피연산자` | 우측의 피연산자의 값과 변수의 값을 >>> 연산 후 결과를 변수에 저장<br>(변수 = 변수 >>> 피연산자) |

## 4강 조건문과 반복문

### (1) if 문
```
if ( 조건식 ) { //실행문이 하나라면 중괄호 생략 가능
    실행문;
    실행문;
}
```

### (2) if-else 문
```
if ( 조건식 ) {

} else {

}
```

### (3) if - else if 문
```

if ( 조건식 ) {

} else if {

} else {

}
```

### (4) switch 문
```
switch(변수) {
  case 값1:

    break;
  case 값2:

    break;
  default:

} //반환값 yield
```

### (5) for 문
```
for(초기화식; 조건식; 증감식) {
실행문;
}
```

### (6) while 문
```
while( 조건식 ) {
실행문;
}
```

### (7) do-while 문
```
do {
실행문;
} while(조건식);
```

### (8) break 문
- for, while 문 모두 사용 가능

### (9) continue 문
- for, while, do-while문 에서만 사용됨.

## 5강 참조 타입

### (1) 문자열 타입
#### 문자열 비교
- equals () 메소드 사용
#### 문자 추출
- charAt() 메소드 : 매개값으로 주어진 인덱스의 문자 리턴
#### 문자열 길이
- length() 메소드
#### 문자열 대체
- replace()

### (2) 배열(Array) 타입
- 같은 타입의 값만 관리
- 배열의 길이는 늘리거나 줄일 수 없음

#### 배열 변수 선언
- 타입[] 변수;
- 타입 변수[];

#### 배열 길이
- 배열변수.length;

### (3) 다차원 배열
```
타입[][] 변수 = {
  {값1, 값2, ...},
  {값3, 값4, ...}
};
// 타입[][] 변수 = new 타입[1차원수][2차원수];
```

## 6강 클래스

### (1) 클래스
```
public class ClassName {
  //필드 선언
  int fieldName;

  //생성자 선언
  ClassName() { … }

  //메소드 선언
  int methodName() { … }
}
```

### (2) 생성자 선언과 호출
```
클래스 변수 = new 클래스(); // 호출

//생성자 선언
클래스(매개변수, …) {
//객체의 초기화 코드
}
```

### (3) 메소드 선언과 호출
```
//메소드 선언
리턴타입 메소드명 (매개변수, …) {

실행코드;

}

//메소드 호출
타입 변수 = 메소드();
```

### (4) return 문
- return [리턴값];

### (5) 인스턴스 멤버
```
public class Car {
  //인스턴스 멤버 선언
  int gas;

  //인스턴스 메소드 선언
  void setSpeed(int Speed) { … }
}
```
#### this
- 생성자와 메소드의 매개변수명이 인스턴스 멤버인 필드명과 동일한 경우, 인스턴스 필드임을 강조하고자 사용

### (6) 정적 멤버
```
public class 클래스 {
  //정적 필드 선언
  static 타입 필드 [= 초기값];

  //정적 메소드
  static 리턴타입 메소드( 매개변수, … ) { … }
}
```

### (7) final 필드와 상수

#### final 필드 선언
- final 타입 필드 [=초기값];
- 초기값 주는 법
    - 필드 선언 시에 초기값 대입
    - 생성자에서 초기값 대입

#### 상수 선언
```
static fianl 타입 상수 [=초기값];

static fianl 타입 상수;
static {
  상수 = 초기값;
}
```

### (8) 패키지

```
package 상위패키지.하위패키지;

public class 클래스명 { … }
```

#### import 문
```
package com.mycompany;

import com.hankook.Tire;

public class Car {
  //필드 선언 시 com.hankook.Tire 클래스를 사용
  Tire tire = new Tire();
}
```
### (9) 접근제한자
|접근 제한자|제한 대상|제한 범위|
|-|-|-|
|public|클래스, 필드, 생성자, 메소드|없음|
|protected|필드, 생성자, 메소드|같은 패키지이거나, 자식 객체만 사용 가능|
|(default)|클래스, 필드, 생성자, 메소드|같은 패키지|
|private|필드, 생성자, 메소드|객체 내부|
